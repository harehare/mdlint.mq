include "lint"
| include "test"

# Test data for MD001 - Heading levels should only increment by one level at a time
def test_md001_valid_heading_progression():
  let content = to_markdown("# H1\n## H2\n### H3\n")
  | let result = md001(content)
  | assert_eq(len(result), 0)
end

def test_md001_invalid_heading_skip():
  let content = to_markdown("# H1\n### H3 (skipped H2)\n")
  | let result = md001(content)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD001")
  | assert_eq(result[0]["severity"], "error")
end

# Test data for MD002 - First header should be a top level header
def test_md002_valid_first_header():
  let config = default_config()
  | let content = to_markdown("# First Header\n## Second Header\n")
  | let result = md002(content, config)
  | assert_eq(len(result), 0)
end

def test_md002_invalid_first_header():
  let config = default_config()
  | let content = to_markdown("## Not H1\n### Another Header\n")
  | let result = md002(content, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD002")
  | assert_eq(result[0]["severity"], "error")
end

# Test data for MD003 - Heading style consistency
def test_md003_consistent_atx_style():
  let config = default_config()
  | let raw_content = "# Header 1\n## Header 2\n### Header 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md003_inconsistent_styles():
  let config = default_config()
  | let raw_content = "# Header 1\n## Header 2\n### Header 3 ###\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD003")
  | assert_eq(result[0]["severity"], "error")
end

def test_md003_enforce_atx_style():
  let config = {
    lint: {
      rules: ["MD003"],
      md003: {style: "atx"}
    }
  }
  | let raw_content = "# Header 1\n## Header 2 ##\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD003")
  | assert_eq(result[0]["details"]["expected"], "atx")
  | assert_eq(result[0]["details"]["found"], "atx_closed")
end

def test_md003_enforce_atx_closed_style():
  let config = {
    lint: {
      rules: ["MD003"],
      md003: {style: "atx_closed"}
    }
  }
  | let raw_content = "# Header 1 #\n## Header 2 ##\n### Header 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["details"]["expected"], "atx_closed")
  | assert_eq(result[0]["details"]["found"], "atx")
end

def test_md003_consistent_setext_style():
  let config = default_config()
  | let raw_content = "Header 1\n========\n\nHeader 2\n--------\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md003_enforce_setext_style():
  let config = {
    lint: {
      rules: ["MD003"],
      md003: {style: "setext"}
    }
  }
  | let raw_content = "Header 1\n========\n\n## Header 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD003")
  | assert_eq(result[0]["details"]["expected"], "setext")
  | assert_eq(result[0]["details"]["found"], "atx")
end

def test_md003_mixed_atx_and_setext():
  let config = default_config()
  | let raw_content = "# Header 1\n\nHeader 2\n--------\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD003")
  | assert_eq(result[0]["details"]["expected"], "atx")
  | assert_eq(result[0]["details"]["found"], "setext")
end

def test_md003_setext_h1_only():
  let config = default_config()
  | let raw_content = "Header 1\n========\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md003_setext_h2_only():
  let config = default_config()
  | let raw_content = "Header 2\n--------\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md003(content, lines, config)
  | assert_eq(len(result), 0)
end

# Test data for MD004 - Unordered list style
def test_md004_consistent_dash_style():
  let config = default_config()
  | let raw_content = "- Item 1\n- Item 2\n- Item 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md004(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md004_consistent_asterisk_style():
  let config = default_config()
  | let raw_content = "* Item 1\n* Item 2\n* Item 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md004(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md004_consistent_plus_style():
  let config = default_config()
  | let raw_content = "+ Item 1\n+ Item 2\n+ Item 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md004(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md004_inconsistent_styles():
  let config = default_config()
  | let raw_content = "- Item 1\n* Item 2\n+ Item 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md004(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["rule"], "MD004")
  | assert_eq(result[0]["severity"], "error")
end

def test_md004_enforce_dash_style():
  let config = {
    lint: {
      rules: ["MD004"],
      md004: {style: "dash"}
    }
  }
  | let raw_content = "- Item 1\n* Item 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md004(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD004")
  | assert_eq(result[0]["details"]["expected"], "dash")
  | assert_eq(result[0]["details"]["found"], "asterisk")
end

def test_md004_enforce_asterisk_style():
  let config = {
    lint: {
      rules: ["MD004"],
      md004: {style: "asterisk"}
    }
  }
  | let raw_content = "* Item 1\n- Item 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md004(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["details"]["expected"], "asterisk")
  | assert_eq(result[0]["details"]["found"], "dash")
end

def test_md004_enforce_plus_style():
  let config = {
    lint: {
      rules: ["MD004"],
      md004: {style: "plus"}
    }
  }
  | let raw_content = "+ Item 1\n- Item 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md004(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["details"]["expected"], "plus")
  | assert_eq(result[0]["details"]["found"], "dash")
end

# Test data for MD009 - Trailing spaces
def test_md009_no_trailing_spaces():
  let config = default_config()
  | let raw_content = "Line 1\nLine 2\nLine 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md009(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md009_single_trailing_space():
  let config = default_config()
  | let raw_content = "Line 1 \nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md009(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD009")
  | assert_eq(result[0]["severity"], "warning")
  | assert_eq(result[0]["details"]["count"], 1)
end

def test_md009_multiple_trailing_spaces():
  let config = default_config()
  | let raw_content = "Line 1   \nLine 2    \n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md009(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["rule"], "MD009")
end

def test_md009_line_break_spaces_allowed():
  let config = default_config()
  | let raw_content = "Line 1  \nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md009(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md009_strict_mode():
  let config = {
    lint: {
      rules: ["MD009"],
      md009: {br_spaces: 2, strict: true}
    }
  }
  | let raw_content = "Line 1  \nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md009(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD009")
end

def test_md009_custom_br_spaces():
  let config = {
    lint: {
      rules: ["MD009"],
      md009: {br_spaces: 3, strict: false}
    }
  }
  | let raw_content = "Line 1   \nLine 2  \n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md009(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["details"]["count"], 2)
end

# Test data for MD010 - Hard tabs
def test_md010_no_tabs():
  let config = default_config()
  | let raw_content = "Line 1\nLine 2\nLine 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md010(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md010_tabs_found():
  let config = default_config()
  | let raw_content = "Line 1\tWith Tab\nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md010(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD010")
  | assert_eq(result[0]["severity"], "error")
end

def test_md010_multiple_tabs():
  let config = default_config()
  | let raw_content = "Line 1\tTab\nLine 2\tAnother Tab\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md010(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["rule"], "MD010")
end

def test_md010_tabs_in_code_block_allowed():
  let config = default_config()
  | let raw_content = "# Header\n```\n\tCode with tab\n```\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md010(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md010_tabs_in_code_block_strict():
  let config = {
    lint: {
      rules: ["MD010"],
      md010: {code_blocks: false}
    }
  }
  | let raw_content = "# Header\n```\n\tCode with tab\n```\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md010(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD010")
end

def test_md010_tabs_outside_code_block():
  let config = default_config()
  | let raw_content = "\tTab before code\n```\n\tCode with tab\n```\n\tTab after code\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md010(content, lines, config)
  | assert_eq(len(result), 2)
end

# Test data for MD012 - Multiple consecutive blank lines
def test_md012_single_blank_line():
  let config = default_config()
  | let raw_content = "Line 1\n\nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md012(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md012_multiple_blank_lines():
  let config = default_config()
  | let raw_content = "Line 1\n\n\nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md012(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD012")
  | assert_eq(result[0]["severity"], "error")
  | assert_eq(result[0]["details"]["count"], 2)
end

def test_md012_three_blank_lines():
  let config = default_config()
  | let raw_content = "Line 1\n\n\n\nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md012(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["details"]["count"], 3)
end

def test_md012_custom_maximum():
  let config = {
    lint: {
      rules: ["MD012"],
      md012: {maximum: 2}
    }
  }
  | let raw_content = "Line 1\n\n\nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md012(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md012_custom_maximum_exceeded():
  let config = {
    lint: {
      rules: ["MD012"],
      md012: {maximum: 2}
    }
  }
  | let raw_content = "Line 1\n\n\n\nLine 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md012(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["details"]["count"], 3)
end

def test_md012_multiple_violations():
  let config = default_config()
  | let raw_content = "Line 1\n\n\nLine 2\n\n\nLine 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md012(content, lines, config)
  | assert_eq(len(result), 2)
end

# Test data for MD013 - Line length
def test_md013_short_lines():
  let config = default_config()
  | let raw_content = "Short line\nAnother short line\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md013(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md013_long_line():
  let config = default_config()
  | let raw_content = "This is a very long line that exceeds the default maximum line length of 80 characters\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md013(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD013")
  | assert_eq(result[0]["severity"], "warning")
end

def test_md013_custom_line_length():
  let config = {
    lint: {
      rules: ["MD013"],
      md013: {line_length: 50, code_blocks: true, tables: true, headings: true}
    }
  }
  | let raw_content = "This line is longer than 50 characters but shorter than 80\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md013(content, lines, config)
  | assert_eq(len(result), 1)
end

def test_md013_code_block_excluded():
  let config = default_config()
  | let raw_content = "# Header\n```\nThis is a very long line in a code block that exceeds the default maximum line length\n```\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md013(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md013_code_block_included():
  let config = {
    lint: {
      rules: ["MD013"],
      md013: {line_length: 80, code_blocks: false, tables: true, headings: true}
    }
  }
  | let raw_content = "# Header\n```\nThis is a very long line in a code block that exceeds the default maximum line length\n```\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md013(content, lines, config)
  | assert_eq(len(result), 1)
end

def test_md013_heading_excluded():
  let config = {
    lint: {
      rules: ["MD013"],
      md013: {line_length: 80, code_blocks: true, tables: true, headings: false}
    }
  }
  | let raw_content = "# This is a very long heading that exceeds the default maximum line length of 80 characters\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md013(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md013_table_excluded():
  let config = default_config()
  | let raw_content = "| Column 1 | This is a very long column that exceeds the default maximum line length of 80 characters |\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md013(content, lines, config)
  | assert_eq(len(result), 0)
end

# Test data for MD014 - Dollar signs in commands
def test_md014_no_dollar_signs():
  let config = default_config()
  | let raw_content = "# Header\n```bash\nls -la\ncd /home\n```\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md014(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md014_dollar_sign_found():
  let config = default_config()
  | let raw_content = "# Header\n```bash\n$ ls -la\n```\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md014(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD014")
  | assert_eq(result[0]["severity"], "warning")
end

def test_md014_multiple_dollar_signs():
  let config = default_config()
  | let raw_content = "# Header\n```bash\n$ ls -la\n$ cd /home\n$ pwd\n```\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md014(content, lines, config)
  | assert_eq(len(result), 3)
  | assert_eq(result[0]["rule"], "MD014")
end

def test_md014_no_code_block():
  let config = default_config()
  | let raw_content = "$ This is not in a code block\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md014(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md014_mixed_commands():
  let config = default_config()
  | let raw_content = "```bash\nls -la\n$ pwd\ncd /home\n$ echo test\n```\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md014(content, lines, config)
  | assert_eq(len(result), 2)
end

# Test data for MD018 - No space after hash
def test_md018_proper_spacing():
  let config = default_config()
  | let raw_content = "# Header 1\n## Header 2\n### Header 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md018(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md018_no_space_after_hash():
  let config = default_config()
  | let raw_content = "#Header without space\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md018(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD018")
  | assert_eq(result[0]["severity"], "error")
end

def test_md018_multiple_hashes_no_space():
  let config = default_config()
  | let raw_content = "##Header\n###Another\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md018(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["rule"], "MD018")
end

def test_md018_mixed_headers():
  let config = default_config()
  | let raw_content = "# Good Header\n##Bad Header\n### Another Good\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md018(content, lines, config)
  | assert_eq(len(result), 1)
end

def test_md018_closed_atx_style():
  let config = default_config()
  | let raw_content = "# Header #\n## Header 2 ##\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md018(content, lines, config)
  | assert_eq(len(result), 0)
end

# Test data for MD019 - Multiple spaces after hash
def test_md019_single_space():
  let config = default_config()
  | let raw_content = "# Header 1\n## Header 2\n### Header 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md019(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md019_multiple_spaces():
  let config = default_config()
  | let raw_content = "#  Header with two spaces\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md019(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD019")
  | assert_eq(result[0]["severity"], "error")
end

def test_md019_three_spaces():
  let config = default_config()
  | let raw_content = "##   Header with three spaces\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md019(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD019")
end

def test_md019_mixed_headers():
  let config = default_config()
  | let raw_content = "# Good Header\n##  Bad Header\n### Another Good\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md019(content, lines, config)
  | assert_eq(len(result), 1)
end

def test_md019_multiple_violations():
  let config = default_config()
  | let raw_content = "#  Header 1\n##  Header 2\n###  Header 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md019(content, lines, config)
  | assert_eq(len(result), 3)
end

# Test data for MD020 - No space inside closing hashes
def test_md020_proper_spacing():
  let config = default_config()
  | let raw_content = "# Header #\n## Header 2 ##\n### Header 3 ###\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md020(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md020_no_space_after_opening():
  let config = default_config()
  | let raw_content = "#Header #\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md020(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD020")
  | assert_eq(result[0]["severity"], "error")
end

def test_md020_no_space_before_closing():
  let config = default_config()
  | let raw_content = "# Header#\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md020(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD020")
end

def test_md020_no_space_both_sides():
  let config = default_config()
  | let raw_content = "#Header#\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md020(content, lines, config)
  | assert_eq(len(result), 1)
end

def test_md020_multiple_violations():
  let config = default_config()
  | let raw_content = "#Header #\n## Header2##\n###Header 3###\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md020(content, lines, config)
  | assert_eq(len(result), 3)
end

# Test data for MD021 - Multiple spaces inside closing hashes
def test_md021_proper_spacing():
  let config = default_config()
  | let raw_content = "# Header #\n## Header 2 ##\n### Header 3 ###\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md021(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md021_multiple_spaces_after_opening():
  let config = default_config()
  | let raw_content = "#  Header #\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md021(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD021")
  | assert_eq(result[0]["severity"], "error")
end

def test_md021_multiple_spaces_before_closing():
  let config = default_config()
  | let raw_content = "# Header  #\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md021(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD021")
end

def test_md021_multiple_spaces_both_sides():
  let config = default_config()
  | let raw_content = "#  Header  #\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md021(content, lines, config)
  | assert_eq(len(result), 1)
end

def test_md021_multiple_violations():
  let config = default_config()
  | let raw_content = "#  Header #\n##  Header 2  ##\n###   Header 3 ###\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md021(content, lines, config)
  | assert_eq(len(result), 3)
end

# Test data for MD022 - Headers should be surrounded by blank lines
def test_md022_proper_blank_lines():
  let config = default_config()
  | let raw_content = "# Header 1\n\nSome text\n\n## Header 2\n\nMore text\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md022(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md022_missing_blank_above():
  let config = default_config()
  | let raw_content = "Some text\n# Header\n\nMore text\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md022(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD022")
  | assert_eq(result[0]["details"]["position"], "above")
end

def test_md022_missing_blank_below():
  let config = default_config()
  | let raw_content = "# Header\nSome text\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md022(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD022")
  | assert_eq(result[0]["details"]["position"], "below")
end

def test_md022_first_line_ok():
  let config = default_config()
  | let raw_content = "# Header\n\nSome text\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md022(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md022_setext_style():
  let config = default_config()
  | let raw_content = "Some text\n\nHeader\n======\n\nMore text\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md022(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md022_setext_missing_blank():
  let config = default_config()
  | let raw_content = "Some text\nHeader\n======\nMore text\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md022(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["rule"], "MD022")
end

# Test data for MD023 - Headers must start at the beginning of the line
def test_md023_no_indentation():
  let config = default_config()
  | let raw_content = "# Header 1\n## Header 2\n### Header 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md023(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md023_indented_atx_header():
  let config = default_config()
  | let raw_content = " # Indented Header\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md023(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD023")
  | assert_eq(result[0]["severity"], "error")
end

def test_md023_tab_indented_header():
  let config = default_config()
  | let raw_content = "\t# Tab Indented Header\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md023(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD023")
end

def test_md023_indented_setext_header():
  let config = default_config()
  | let raw_content = " Header\n======\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md023(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD023")
end

def test_md023_multiple_indented_headers():
  let config = default_config()
  | let raw_content = " # Header 1\n  ## Header 2\n   ### Header 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md023(content, lines, config)
  | assert_eq(len(result), 3)
end

# Test data for MD024 - Multiple headers with the same content
def test_md024_no_duplicate_headers():
  let config = default_config()
  | let content = to_markdown("# Header 1\n## Header 2\n### Header 3\n")
  | let result = md024(content, config)
  | assert_eq(len(result), 0)
end

def test_md024_duplicate_headers():
  let config = default_config()
  | let content = to_markdown("# Test\n## Test\n")
  | let result = md024(content, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD024")
  | assert_eq(result[0]["severity"], "warning")
end

# Test data for MD025 - Multiple top level headers
def test_md025_single_h1():
  let config = default_config()
  | let content = to_markdown("# Only One H1\n## H2\n### H3\n")
  | let result = md025(content, config)
  | assert_eq(len(result), 0)
end

def test_md025_multiple_h1():
  let config = default_config()
  | let content = to_markdown("# First H1\n## H2\n# Second H1\n")
  | let result = md025(content, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD025")
  | assert_eq(result[0]["severity"], "error")
end

# Test data for MD026 - Trailing punctuation in header
def test_md026_no_trailing_punctuation():
  let config = default_config()
  | let content = to_markdown("# Clean Header\n## Another Clean Header\n")
  | let result = md026(content, config)
  | assert_eq(len(result), 0)
end

def test_md026_trailing_period():
  let config = default_config()
  | let content = to_markdown("# Header with period.\n")
  | let result = md026(content, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD026")
  | assert_eq(result[0]["severity"], "warning")
end

def test_md026_trailing_question():
  let config = default_config()
  | let content = to_markdown("# Header with question?\n")
  | let result = md026(content, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD026")
end

# Test data for MD027 - Multiple spaces after blockquote symbol
def test_md027_single_space():
  let config = default_config()
  | let raw_content = "> This is a blockquote\n> Another line\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md027(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md027_multiple_spaces():
  let config = default_config()
  | let raw_content = ">  Two spaces after symbol\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md027(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD027")
  | assert_eq(result[0]["severity"], "error")
end

def test_md027_three_spaces():
  let config = default_config()
  | let raw_content = ">   Three spaces after symbol\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md027(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD027")
end

def test_md027_mixed_blockquotes():
  let config = default_config()
  | let raw_content = "> Good blockquote\n>  Bad blockquote\n> Another good one\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md027(content, lines, config)
  | assert_eq(len(result), 1)
end

def test_md027_multiple_violations():
  let config = default_config()
  | let raw_content = ">  Bad 1\n>  Bad 2\n>   Bad 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md027(content, lines, config)
  | assert_eq(len(result), 3)
end

def test_md027_nested_blockquotes():
  let config = default_config()
  | let raw_content = "> Level 1\n>> Level 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md027(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md027_no_space_after_symbol():
  let config = default_config()
  | let raw_content = ">No space after symbol\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md027(content, lines, config)
  | assert_eq(len(result), 0)
end

# Test data for MD028 - Blank line inside blockquote
def test_md028_no_blank_lines():
  let config = default_config()
  | let raw_content = "> Quote line 1\n> Quote line 2\n> Quote line 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md028(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md028_blank_with_marker():
  let config = default_config()
  | let raw_content = "> Quote line 1\n>\n> Quote line 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md028(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md028_blank_line_violation():
  let config = default_config()
  | let raw_content = "> Quote line 1\n\n> Quote line 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md028(content, lines, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD028")
  | assert_eq(result[0]["severity"], "error")
end

def test_md028_text_between_blockquotes():
  let config = default_config()
  | let raw_content = "> Quote 1\n\nSome text\n\n> Quote 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md028(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md028_multiple_violations():
  let config = default_config()
  | let raw_content = "> Quote 1\n\n> Quote 2\n\n> Quote 3\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md028(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["rule"], "MD028")
  | assert_eq(result[1]["rule"], "MD028")
end

def test_md028_single_blockquote():
  let config = default_config()
  | let raw_content = "> This is a single blockquote\n> with multiple lines\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md028(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md028_nested_blockquote():
  let config = default_config()
  | let raw_content = "> Level 1\n>> Level 2\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md028(content, lines, config)
  | assert_eq(len(result), 0)
end

# Test data for MD029 - Ordered list item prefix
def test_md029_one_style():
  let config = {
    lint: {
      rules: ["MD029"],
      md029: {style: "one"}
    }
  }
  | let raw_content = "1. First item\n1. Second item\n1. Third item\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md029_ordered_style():
  let config = {
    lint: {
      rules: ["MD029"],
      md029: {style: "ordered"}
    }
  }
  | let raw_content = "1. First item\n2. Second item\n3. Third item\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md029_zero_style():
  let config = {
    lint: {
      rules: ["MD029"],
      md029: {style: "zero"}
    }
  }
  | let raw_content = "0. First item\n0. Second item\n0. Third item\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md029_one_or_ordered_accepts_one():
  let config = default_config()
  | let raw_content = "1. First item\n1. Second item\n1. Third item\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md029_one_or_ordered_accepts_ordered():
  let config = default_config()
  | let raw_content = "1. First item\n2. Second item\n3. Third item\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md029_one_style_violation():
  let config = {
    lint: {
      rules: ["MD029"],
      md029: {style: "one"}
    }
  }
  | let raw_content = "1. First item\n2. Second item\n3. Third item\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["rule"], "MD029")
  | assert_eq(result[0]["severity"], "error")
end

def test_md029_ordered_style_violation():
  let config = {
    lint: {
      rules: ["MD029"],
      md029: {style: "ordered"}
    }
  }
  | let raw_content = "1. First item\n1. Second item\n1. Third item\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["rule"], "MD029")
end

def test_md029_skip_code_blocks():
  let config = default_config()
  | let raw_content = "1. First item\n```\n2. Code example\n```\n2. Second item\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 0)
end

def test_md029_wrong_sequence():
  let config = {
    lint: {
      rules: ["MD029"],
      md029: {style: "ordered"}
    }
  }
  | let raw_content = "1. First\n3. Third (skipped 2)\n4. Fourth\n"
  | let content = to_markdown(raw_content)
  | let lines = split(raw_content, "\n")
  | let result = md029(content, lines, config)
  | assert_eq(len(result), 2)
  | assert_eq(result[0]["details"]["expected"], 2)
  | assert_eq(result[0]["details"]["actual"], 3)
end

# Test data for MD033 - Inline HTML
def test_md033_no_html():
  let config = default_config()
  | let content = to_markdown("# Header\n\nJust plain text.\n")
  | let result = md033(content, config)
  | assert_eq(len(result), 0)
end

def test_md033_inline_html():
  let config = default_config()
  | let content = to_markdown("# Header\n\n<div>Some HTML</div>\n")
  | let result = md033(content, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD033")
  | assert_eq(result[0]["severity"], "warning")
end

# Test data for MD040 - Fenced code blocks should have a language
def test_md040_code_with_language():
  let config = default_config()
  | let content = to_markdown("# Header\n\n```javascript\nconsole.log('test');\n```\n")
  | let result = md040(content, config)
  | assert_eq(len(result), 0)
end

def test_md040_code_without_language():
  let config = default_config()
  | let content = to_markdown("# Header\n\n```\ncode without language\n```\n")
  | let result = md040(content, config)
  | assert_eq(len(result), 1)
  | assert_eq(result[0]["rule"], "MD040")
  | assert_eq(result[0]["severity"], "warning")
end

# Test helper functions
def test_format_issue():
  let issue = {
    rule: "MD001",
    name: "heading-increment",
    severity: "error",
    message: "Test message",
    line: 5
  }
  | let formatted = format_issue(issue)
  | assert_eq(contains(formatted, "MD001"), true)
  | assert_eq(contains(formatted, "heading-increment"), true)
  | assert_eq(contains(formatted, "Test message"), true)
end

def test_count_by_severity():
  let issues = [
    {severity: "error"},
    {severity: "error"},
    {severity: "warning"},
    {severity: "info"}
  ]
  | let counts = count_by_severity(issues)
  | assert_eq(counts["errors"], 2)
  | assert_eq(counts["warnings"], 1)
  | assert_eq(counts["info"], 1)
  | assert_eq(counts["total"], 4)
end

# Integration test with lint_all
def test_lint_all_clean_document():
  let content = "# Title\n\n## Section\n\nContent here.\n"
  | let result = lint_all(content)
  | assert_eq(result["summary"]["errors"], 0)
end

def test_lint_all_with_issues():
  let content = "## Not H1\n\n### Skipped Level\n\n# Duplicate\n\n# Duplicate\n"
  | let result = lint_all(content)
  | let total = result["summary"]["total"]
  | assert_eq(total > 0, true)
end

# Test generate_report function
def test_generate_report_no_issues():
  let lint_result = {
    issues: [],
    summary: {errors: 0, warnings: 0, info: 0, total: 0}
  }
  | let report = generate_report(lint_result)
  | assert_eq(contains(report, "No issues found"), true)
end

def test_generate_report_with_issues():
  let issue = {
    rule: "MD001",
    name: "heading-increment",
    severity: "error",
    message: "Test issue",
    line: 1
  }
  | let lint_result = {
    issues: [issue],
    summary: {errors: 1, warnings: 0, info: 0, total: 1}
  }
  | let report = generate_report(lint_result)
  | assert_eq(contains(report, "Markdown Lint Report"), true)
  | assert_eq(contains(report, "Found 1 issues"), true)
end

# Test configuration functions
def test_default_config():
  let config = default_config()
  | assert_eq(contains(config["lint"]["rules"], "MD001"), true)
  | assert_eq(contains(config["lint"]["rules"], "MD002"), true)
  | assert_eq(config["lint"]["md002"]["level"], 1)
end

def test_is_rule_enabled():
  let config = default_config()
  | assert_eq(is_rule_enabled(config, "MD001"), true)
  | assert_eq(is_rule_enabled(config, "MD002"), true)
  | assert_eq(is_rule_enabled(config, "MD003"), true)
  | assert_eq(is_rule_enabled(config, "MD004"), true)
end

def test_get_rule_config():
  let config = default_config()
  | let md002_config = get_rule_config(config, "md002")
  | assert_eq(md002_config["level"], 1)
  | let md026_config = get_rule_config(config, "md026")
  | assert_eq(md026_config["punctuation"], ".,;:!?")
end

def test_custom_config_md026():
  let config = {
    lint: {
      rules: ["MD026"],
      md026: {punctuation: ".!"}
    }
  }
  | let content = to_markdown("# Header with comma,\n")
  | let result = md026(content, config)
  | assert_eq(len(result), 0)
  | let content2 = to_markdown("# Header with period.\n")
  | let result2 = md026(content2, config)
  | assert_eq(len(result2), 1)
end

def test_lint_all_with_disabled_rules():
  let config = {
    lint: {
      rules: ["MD002"],
      md002: {level: 1},
      md024: {"siblings-only": false},
      md025: {level: 1},
      md026: {punctuation: ".,;:!?"},
      md033: {"allowed-elements": []},
      md040: {enabled: true}
    }
  }
  | let content = "## Not H1\n\n### Skipped Level\n"
  | let result = lint_all_with_config(content, config)
  | let total = result["summary"]["total"]
  | assert_eq(total, 1)
end

run_tests([
  test_case("MD001: Valid heading progression", test_md001_valid_heading_progression),
  test_case("MD001: Invalid heading skip", test_md001_invalid_heading_skip),
  test_case("MD002: Valid first header", test_md002_valid_first_header),
  test_case("MD002: Invalid first header", test_md002_invalid_first_header),
  test_case("MD003: Consistent ATX style", test_md003_consistent_atx_style),
  test_case("MD003: Inconsistent styles", test_md003_inconsistent_styles),
  test_case("MD003: Enforce ATX style", test_md003_enforce_atx_style),
  test_case("MD003: Enforce ATX closed style", test_md003_enforce_atx_closed_style),
  test_case("MD003: Consistent setext style", test_md003_consistent_setext_style),
  test_case("MD003: Enforce setext style", test_md003_enforce_setext_style),
  test_case("MD003: Mixed ATX and setext", test_md003_mixed_atx_and_setext),
  test_case("MD003: Setext H1 only", test_md003_setext_h1_only),
  test_case("MD003: Setext H2 only", test_md003_setext_h2_only),
  test_case("MD004: Consistent dash style", test_md004_consistent_dash_style),
  test_case("MD004: Consistent asterisk style", test_md004_consistent_asterisk_style),
  test_case("MD004: Consistent plus style", test_md004_consistent_plus_style),
  test_case("MD004: Inconsistent styles", test_md004_inconsistent_styles),
  test_case("MD004: Enforce dash style", test_md004_enforce_dash_style),
  test_case("MD004: Enforce asterisk style", test_md004_enforce_asterisk_style),
  test_case("MD004: Enforce plus style", test_md004_enforce_plus_style),
  test_case("MD009: No trailing spaces", test_md009_no_trailing_spaces),
  test_case("MD009: Single trailing space", test_md009_single_trailing_space),
  test_case("MD009: Multiple trailing spaces", test_md009_multiple_trailing_spaces),
  test_case("MD009: Line break spaces allowed", test_md009_line_break_spaces_allowed),
  test_case("MD009: Strict mode", test_md009_strict_mode),
  test_case("MD009: Custom br_spaces", test_md009_custom_br_spaces),
  test_case("MD010: No tabs", test_md010_no_tabs),
  test_case("MD010: Tabs found", test_md010_tabs_found),
  test_case("MD010: Multiple tabs", test_md010_multiple_tabs),
  test_case("MD010: Tabs in code block allowed", test_md010_tabs_in_code_block_allowed),
  test_case("MD010: Tabs in code block strict", test_md010_tabs_in_code_block_strict),
  test_case("MD010: Tabs outside code block", test_md010_tabs_outside_code_block),
  test_case("MD012: Single blank line", test_md012_single_blank_line),
  test_case("MD012: Multiple blank lines", test_md012_multiple_blank_lines),
  test_case("MD012: Three blank lines", test_md012_three_blank_lines),
  test_case("MD012: Custom maximum", test_md012_custom_maximum),
  test_case("MD012: Custom maximum exceeded", test_md012_custom_maximum_exceeded),
  test_case("MD012: Multiple violations", test_md012_multiple_violations),
  test_case("MD013: Short lines", test_md013_short_lines),
  test_case("MD013: Long line", test_md013_long_line),
  test_case("MD013: Custom line length", test_md013_custom_line_length),
  test_case("MD013: Code block excluded", test_md013_code_block_excluded),
  test_case("MD013: Code block included", test_md013_code_block_included),
  test_case("MD013: Heading excluded", test_md013_heading_excluded),
  test_case("MD013: Table excluded", test_md013_table_excluded),
  test_case("MD014: No dollar signs", test_md014_no_dollar_signs),
  test_case("MD014: Dollar sign found", test_md014_dollar_sign_found),
  test_case("MD014: Multiple dollar signs", test_md014_multiple_dollar_signs),
  test_case("MD014: No code block", test_md014_no_code_block),
  test_case("MD014: Mixed commands", test_md014_mixed_commands),
  test_case("MD018: Proper spacing", test_md018_proper_spacing),
  test_case("MD018: No space after hash", test_md018_no_space_after_hash),
  test_case("MD018: Multiple hashes no space", test_md018_multiple_hashes_no_space),
  test_case("MD018: Mixed headers", test_md018_mixed_headers),
  test_case("MD018: Closed atx style", test_md018_closed_atx_style),
  test_case("MD019: Single space", test_md019_single_space),
  test_case("MD019: Multiple spaces", test_md019_multiple_spaces),
  test_case("MD019: Three spaces", test_md019_three_spaces),
  test_case("MD019: Mixed headers", test_md019_mixed_headers),
  test_case("MD019: Multiple violations", test_md019_multiple_violations),
  test_case("MD020: Proper spacing", test_md020_proper_spacing),
  test_case("MD020: No space after opening", test_md020_no_space_after_opening),
  test_case("MD020: No space before closing", test_md020_no_space_before_closing),
  test_case("MD020: No space both sides", test_md020_no_space_both_sides),
  test_case("MD020: Multiple violations", test_md020_multiple_violations),
  test_case("MD021: Proper spacing", test_md021_proper_spacing),
  test_case("MD021: Multiple spaces after opening", test_md021_multiple_spaces_after_opening),
  test_case("MD021: Multiple spaces before closing", test_md021_multiple_spaces_before_closing),
  test_case("MD021: Multiple spaces both sides", test_md021_multiple_spaces_both_sides),
  test_case("MD021: Multiple violations", test_md021_multiple_violations),
  test_case("MD022: Proper blank lines", test_md022_proper_blank_lines),
  test_case("MD022: Missing blank above", test_md022_missing_blank_above),
  test_case("MD022: Missing blank below", test_md022_missing_blank_below),
  test_case("MD022: First line OK", test_md022_first_line_ok),
  test_case("MD022: Setext style", test_md022_setext_style),
  test_case("MD022: Setext missing blank", test_md022_setext_missing_blank),
  test_case("MD023: No indentation", test_md023_no_indentation),
  test_case("MD023: Indented ATX header", test_md023_indented_atx_header),
  test_case("MD023: Tab indented header", test_md023_tab_indented_header),
  test_case("MD023: Indented setext header", test_md023_indented_setext_header),
  test_case("MD023: Multiple indented headers", test_md023_multiple_indented_headers),
  test_case("MD024: No duplicate headers", test_md024_no_duplicate_headers),
  test_case("MD024: Duplicate headers", test_md024_duplicate_headers),
  test_case("MD025: Single H1", test_md025_single_h1),
  test_case("MD025: Multiple H1", test_md025_multiple_h1),
  test_case("MD026: No trailing punctuation", test_md026_no_trailing_punctuation),
  test_case("MD026: Trailing period", test_md026_trailing_period),
  test_case("MD026: Trailing question mark", test_md026_trailing_question),
  test_case("MD027: Single space", test_md027_single_space),
  test_case("MD027: Multiple spaces", test_md027_multiple_spaces),
  test_case("MD027: Three spaces", test_md027_three_spaces),
  test_case("MD027: Mixed blockquotes", test_md027_mixed_blockquotes),
  test_case("MD027: Multiple violations", test_md027_multiple_violations),
  test_case("MD027: Nested blockquotes", test_md027_nested_blockquotes),
  test_case("MD027: No space after symbol", test_md027_no_space_after_symbol),
  test_case("MD028: No blank lines", test_md028_no_blank_lines),
  test_case("MD028: Blank with marker", test_md028_blank_with_marker),
  test_case("MD028: Blank line violation", test_md028_blank_line_violation),
  test_case("MD028: Text between blockquotes", test_md028_text_between_blockquotes),
  test_case("MD028: Multiple violations", test_md028_multiple_violations),
  test_case("MD028: Single blockquote", test_md028_single_blockquote),
  test_case("MD028: Nested blockquote", test_md028_nested_blockquote),
  test_case("MD029: One style", test_md029_one_style),
  test_case("MD029: Ordered style", test_md029_ordered_style),
  test_case("MD029: Zero style", test_md029_zero_style),
  test_case("MD029: One or ordered accepts one", test_md029_one_or_ordered_accepts_one),
  test_case("MD029: One or ordered accepts ordered", test_md029_one_or_ordered_accepts_ordered),
  test_case("MD029: One style violation", test_md029_one_style_violation),
  test_case("MD029: Ordered style violation", test_md029_ordered_style_violation),
  test_case("MD029: Skip code blocks", test_md029_skip_code_blocks),
  test_case("MD029: Wrong sequence", test_md029_wrong_sequence),
  test_case("MD033: No HTML", test_md033_no_html),
  test_case("MD033: Inline HTML", test_md033_inline_html),
  test_case("MD040: Code with language", test_md040_code_with_language),
  test_case("MD040: Code without language", test_md040_code_without_language),
  test_case("Helper: format_issue", test_format_issue),
  test_case("Helper: count_by_severity", test_count_by_severity),
  test_case("Integration: lint_all clean document", test_lint_all_clean_document),
  test_case("Integration: lint_all with issues", test_lint_all_with_issues),
  test_case("Report: generate_report no issues", test_generate_report_no_issues),
  test_case("Report: generate_report with issues", test_generate_report_with_issues),
  test_case("Config: default_config", test_default_config),
  test_case("Config: is_rule_enabled", test_is_rule_enabled),
  test_case("Config: get_rule_config", test_get_rule_config),
  test_case("Config: custom config MD026", test_custom_config_md026),
  test_case("Config: lint_all with disabled rules", test_lint_all_with_disabled_rules)
])
