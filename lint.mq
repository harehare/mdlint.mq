# Markdown Linter - markdownlint Rules Implementation
# This file implements linting rules based on markdownlint
#
# Reference: https://github.com/markdownlint/markdownlint/blob/main/docs/RULES.md

include "toml"

# Default configuration
| def default_config():
    {
      lint: {
        "output-format": "detailed",
        quiet: false,
        rules: ["MD001", "MD002", "MD003", "MD024", "MD025", "MD026", "MD033", "MD040"],
        md002: {level: 1},
        md003: {style: "consistent"},
        md024: {"siblings-only": false},
        md025: {level: 1},
        md026: {punctuation: ".,;:!?"},
        md033: {"allowed-elements": []},
        md040: {enabled: true}
      }
    }
  end

# Load configuration from TOML file
def load_config(path):
  try:
    do
      let content = read_file(path)
      | toml_parse(content)
    end
  catch:
    default_config()
end

# Merge user config with default config
def merge_config(user_config):
  let defaults = default_config()
  | let lint_config = try: user_config["lint"] catch: {}
  | let merged_lint = {
    "output-format": try: lint_config["output-format"] catch: defaults["lint"]["output-format"],
    quiet: try: lint_config["quiet"] catch: defaults["lint"]["quiet"],
    rules: try: lint_config["rules"] catch: defaults["lint"]["rules"],
    md002: try: lint_config["md002"] catch: defaults["lint"]["md002"],
    md003: try: lint_config["md003"] catch: defaults["lint"]["md003"],
    md024: try: lint_config["md024"] catch: defaults["lint"]["md024"],
    md025: try: lint_config["md025"] catch: defaults["lint"]["md025"],
    md026: try: lint_config["md026"] catch: defaults["lint"]["md026"],
    md033: try: lint_config["md033"] catch: defaults["lint"]["md033"],
    md040: try: lint_config["md040"] catch: defaults["lint"]["md040"]
  }
  | {lint: merged_lint}
end

# Check if a rule is enabled
def is_rule_enabled(config, rule_name):
  let rules = config["lint"]["rules"]
  | contains(rules, rule_name)
end

# Get rule-specific configuration
def get_rule_config(config, rule_name):
  let rule_key = downcase(rule_name)
  | try: config["lint"][rule_key] catch: {}
end

# MD001: Header levels should only increment by one level at a time
def md001(content):
  let headings = do content | .h | compact();
  | let levels = do map(headings, fn(h): attr(h, "level");) | filter(fn(level): level > 0;);
  | foreach (i, range(1, len(levels) - 1, 1)):
      let current = levels[i]
      | let previous = levels[i - 1]
      | let diff = current - previous
      | if (diff > 1):
          do
            let heading_node = headings[i]
            | let heading_text = to_text(heading_node)
            | let expected_level = previous + 1
            | {
              rule: "MD001",
              name: "heading-increment",
              severity: "error",
              message: s"Heading level ${current} skipped (expected level ${expected_level} or lower)",
              heading: heading_text,
              line: i + 1,
              details: {previous_level: previous, current_level: current}
            }
          end
    end | compact() | flatten()
end

# MD002: First header should be a top level header
def md002(content, config):
  let rule_config = get_rule_config(config, "md002")
  | let expected_level = try: rule_config["level"] catch: 1
  | let headings = do content | .h | compact();
  | if (is_empty(headings)): []
    else:
      do
        let first_heading = first(headings)
        | let first_level = attr(first_heading, "level")
        | if (first_level != expected_level):
            do
              let heading_text = to_text(first_heading)
              | [{
                rule: "MD002",
                name: "first-header-h1",
                severity: "error",
                message: s"First header should be h${expected_level} (found h${first_level})",
                heading: heading_text,
                line: 1,
                details: {level: first_level, expected: expected_level}
              }]
            end
          else: []
      end
end


def detect_heading_style(line):
  let trimmed = trim(line)
  | if (is_empty(trimmed)): "none"
    elif (starts_with(trimmed, "#")):
      do
        let has_closing_hash = ends_with(trim(trimmed), "#")
        | if (has_closing_hash): "atx_closed"
          else: "atx"
      end
    else: "none"
end

# MD003: Header style consistency
def md003(md, lines, config):
  let rule_config = get_rule_config(config, "md003")
  | let expected_style = try: rule_config["style"] catch: "consistent"
  | let headings = do md | .h | compact();
  | if (is_empty(headings)): []
    else:
      do
        # Detect all heading styles
        let heading_info = foreach (head, headings):
                  let pos = _get_markdown_position(head)
                  | let line_num = pos["start_line"]
                  | let line = if (line_num > 0 && line_num <= len(lines)): lines[line_num - 1] else: ""
                  | let style = detect_heading_style(line)
                  | if (style != "none"): {line: line_num, style: style, text: to_text(head)} else: None
                end

        # Determine the target style
        | let target_style = if (expected_style == "consistent"):
                  if (len(heading_info) > 0): heading_info[0]["style"] else: "atx"
                else: expected_style

        # Check each heading for consistency
        | foreach (info, heading_info):
            let style = info["style"]
            | let line_num = info["line"]
            | let heading_text = info["text"]
            | if (expected_style == "consistent" && style != target_style):
                {
                  rule: "MD003",
                  name: "heading-style",
                  severity: "error",
                  message: s"Inconsistent heading style: expected '${target_style}' but found '${style}'",
                  heading: heading_text,
                  line: line_num,
                  details: {expected: target_style, found: style}
                }
              elif (expected_style != "consistent" && style != target_style):
                {
                  rule: "MD003",
                  name: "heading-style",
                  severity: "error",
                  message: s"Heading style should be '${target_style}' but found '${style}'",
                  heading: heading_text,
                  line: line_num,
                  details: {expected: target_style, found: style}
                }
          end | compact()
      end
end

# MD004: Unordered list style
# TODO: Implement unordered list style consistency check
# Requires access to raw markdown text to detect list markers (-, *, +)
def md004(content): []
end

# MD005: List item indentation consistency
# TODO: Implement list item indentation consistency check
# Requires access to raw markdown text
def md005(content): []
end

# MD006: Consider starting bulleted lists at the beginning of the line
# TODO: Implement check for list starting position
# Requires access to raw markdown text
def md006(content): []
end

# MD007: Unordered list indentation
# TODO: Implement unordered list indentation check
# Requires access to raw markdown text to detect indentation levels
def md007(content): []
end

# MD009: Trailing spaces
# TODO: Implement trailing spaces check
# Requires access to raw markdown text to detect line endings
def md009(content): []
end

# MD010: Hard tabs
# TODO: Implement hard tabs check
# Requires access to raw markdown text to detect tab characters
def md010(content): []
end

# MD011: Reversed link syntax
# TODO: Implement check for reversed link syntax
# Requires analysis of text patterns
def md011(content): []
end

# MD012: Multiple consecutive blank lines
# TODO: Implement multiple consecutive blank lines check
# Requires access to raw markdown text
def md012(content): []
end

# MD013: Line length
# TODO: Implement line length check
# Requires access to raw markdown text
def md013(content): []
end

# MD014: Dollar signs used before commands without showing output
# TODO: Implement check for dollar signs in code blocks
# Requires analysis of code block content
def md014(content): []
end

# MD018: No space after hash on atx style header
# TODO: Implement check for space after hash
# Requires access to raw markdown text
def md018(content): []
end

# MD019: Multiple spaces after hash on atx style header
# TODO: Implement check for multiple spaces after hash
# Requires access to raw markdown text
def md019(content): []
end

# MD020: No space inside hashes on closed atx style header
# TODO: Implement check for space inside closing hashes
# Requires access to raw markdown text
def md020(content): []
end

# MD021: Multiple spaces inside hashes on closed atx style header
# TODO: Implement check for multiple spaces inside closing hashes
# Requires access to raw markdown text
def md021(content): []
end

# MD022: Headers should be surrounded by blank lines
def md022(content): []
end

# MD023: Headers must start at the beginning of the line
# TODO: Implement check for header starting position
# Requires access to raw markdown text
def md023(content): []
end

# MD024: Multiple headers with the same content
def md024(content, config):
  let headings = do content | .h | compact();
  | let issues = []
  | let seen = {}
  | foreach (i, range(0, len(headings) - 1, 1)):
      let heading = headings[i]
      | let heading_text = to_text(heading)
      | if (contains(seen, heading_text)):
          {
            rule: "MD024",
            name: "no-duplicate-header",
            severity: "warning",
            message: s"Multiple headers with the same content: '${heading_text}'",
            heading: heading_text,
            line: i + 1,
            details: {duplicate_text: heading_text}
          }
        elif (!is_none(heading_text)): do
            let seen = set(seen, heading_text, true)
            | None
          end
    end | compact()
end

# MD025: Multiple top level headers in the same document
def md025(content, config):
  let rule_config = get_rule_config(config, "md025")
  | let top_level = try: rule_config["level"] catch: 1
  | let headings = do content | .h | compact();
  | let h1_headings = filter(headings, fn(h): attr(h, "level") == top_level;)
  | if (len(h1_headings) > 1):
      foreach (i, range(1, len(h1_headings) - 1, 1)):
        let heading_text = to_text(h1_headings[i])
        | {
          rule: "MD025",
          name: "single-h1",
          severity: "error",
          message: s"Multiple top level headers found (h${top_level} should be unique)",
          heading: heading_text,
          line: i + 1,
          details: {level: top_level}
        }
      end
    else: []
end

# MD026: Trailing punctuation in header
def md026(content, config):
  let rule_config = get_rule_config(config, "md026")
  | let punctuation = try: rule_config["punctuation"] catch: ".,;:!?"
  | let headings = do content | .h | compact();
  | let issues = []
  | foreach (i, range(0, len(headings) - 1, 1)):
      let heading = headings[i]
      | let heading_text = to_text(heading)
      | let last_char = slice(heading_text, len(heading_text) - 1, len(heading_text))
      | if (contains(punctuation, last_char)):
          do
            {
              rule: "MD026",
              name: "no-trailing-punctuation",
              severity: "warning",
              message: s"Trailing punctuation in header: '${last_char}'",
              heading: heading_text,
              line: i + 1,
              details: {punctuation: last_char}
            }
          end
    end | compact() | flatten()
end

# MD027: Multiple spaces after blockquote symbol
# TODO: Implement check for multiple spaces after blockquote
# Requires access to raw markdown text
def md027(content): []
end

# MD028: Blank line inside blockquote
# TODO: Implement check for blank lines in blockquotes
# Requires access to raw markdown text
def md028(content): []
end

# MD029: Ordered list item prefix
# TODO: Implement ordered list prefix consistency check
# Requires access to raw markdown text
def md029(content): []
end

# MD030: Spaces after list markers
# TODO: Implement check for spaces after list markers
# Requires access to raw markdown text
def md030(content): []
end

# MD031: Fenced code blocks should be surrounded by blank lines
# TODO: Implement check for blank lines around code blocks
# Requires access to raw markdown text
def md031(content): []
end

# MD032: Lists should be surrounded by blank lines
# TODO: Implement check for blank lines around lists
# Requires access to raw markdown text
def md032(content): []
end

# MD033: Inline HTML
def md033(content, config):
  let rule_config = get_rule_config(config, "md033")
  | let allowed_elements = try: rule_config["allowed-elements"] catch: []
  | let html_nodes = do content | .html | compact();
  | if (is_empty(html_nodes)): []
    else: do
        let issues = []
        | foreach (i, range(0, len(html_nodes) - 1, 1)):
            let html_node = html_nodes[i]
            | let html_text = to_text(html_node)
            | {
              rule: "MD033",
              name: "no-inline-html",
              severity: "warning",
              message: s"Inline HTML found: ${html_text}",
              line: i + 1,
              details: {html: html_text}
            }
          end
      end
end

# MD034: Bare URL used
# TODO: Implement bare URL detection
# Requires analysis of link nodes
def md034(content): []
end

# MD035: Horizontal rule style
# TODO: Implement horizontal rule style consistency check
# Requires access to raw markdown text
def md035(content): []
end

# MD036: Emphasis used instead of a header
# TODO: Implement check for emphasis misused as header
# Requires semantic analysis
def md036(content): []
end

# MD037: Spaces inside emphasis markers
# TODO: Implement check for spaces inside emphasis
# Requires access to raw markdown text
def md037(content): []
end

# MD038: Spaces inside code span elements
# TODO: Implement check for spaces inside code spans
# Requires access to raw markdown text
def md038(content): []
end

# MD039: Spaces inside link text
# TODO: Implement check for spaces inside link text
# Requires access to raw markdown text
def md039(content): []
end

# MD040: Fenced code blocks should have a language specified
def md040(content, config):
  let rule_config = get_rule_config(config, "md040")
  | let enabled = try: rule_config["enabled"] catch: true
  | if (!enabled): []
    else: do
        let code_blocks = do content | .code | compact();
        | let issues = []
        | foreach (i, range(0, len(code_blocks) - 1, 1)):
            let code_block = code_blocks[i]
            | let language = attr(code_block, "lang")
            | if (is_empty(language)):
                do
                  {
                    rule: "MD040",
                    name: "fenced-code-language",
                    severity: "warning",
                    message: "Fenced code block should have a language specified",
                    line: i + 1,
                    details: {}
                  }
                end
          end | compact() | flatten()
      end
end

# MD041: First line in file should be a top level header
def md041(content): []
end

# MD046: Code block style
# TODO: Implement code block style consistency check
# Requires access to raw markdown text
def md046(content): []
end

# MD047: File should end with a single newline character
# TODO: Implement check for file ending
# Requires access to raw markdown text
def md047(content): []
end

# Format a single issue for display
def format_issue(issue):
  let rule = get(issue, "rule")
  | let name = get(issue, "name")
  | let line = try: issue["line"] catch: "?"
  | let severity = issue["severity"]
  | let message = issue["message"]
  | let severity_icon = match (severity):
      | "error": "❌"
      | "warning": "⚠️"
      | "info": "ℹ️"
      | _: "•"
    end
  | s"${line}:1 ${severity_icon} ${rule} (${name}) - ${message}"
end

# Count issues by severity
def count_by_severity(issues):
  let errors = do filter(issues, fn(i): i["severity"] == "error";) | len();
  | let warnings = do filter(issues, fn(i): i["severity"] == "warning";) | len();
  | let info = do filter(issues, fn(i): i["severity"] == "info";) | len();
  | {
    "errors": errors,
    "warnings": warnings,
    "info": info,
    "total": len(issues)
  }
end

# Run all lint rules with configuration
def lint_all_with_config(content, config):
  let md = to_markdown(content)
  | let lines = split(content, "\n")
  | let md001_issues = if (is_rule_enabled(config, "MD001")): md001(md) else: []
  | let md002_issues = if (is_rule_enabled(config, "MD002")): md002(md, config) else: []
  | let md003_issues = if (is_rule_enabled(config, "MD003")): md003(md, lines, config) else: []
  | let md004_issues = if (is_rule_enabled(config, "MD004")): md004(md) else: []
  | let md005_issues = if (is_rule_enabled(config, "MD005")): md005(md) else: []
  | let md006_issues = if (is_rule_enabled(config, "MD006")): md006(md) else: []
  | let md007_issues = if (is_rule_enabled(config, "MD007")): md007(md) else: []
  | let md009_issues = if (is_rule_enabled(config, "MD009")): md009(md) else: []
  | let md010_issues = if (is_rule_enabled(config, "MD010")): md010(md) else: []
  | let md011_issues = if (is_rule_enabled(config, "MD011")): md011(md) else: []
  | let md012_issues = if (is_rule_enabled(config, "MD012")): md012(md) else: []
  | let md013_issues = if (is_rule_enabled(config, "MD013")): md013(md) else: []
  | let md014_issues = if (is_rule_enabled(config, "MD014")): md014(md) else: []
  | let md018_issues = if (is_rule_enabled(config, "MD018")): md018(md) else: []
  | let md019_issues = if (is_rule_enabled(config, "MD019")): md019(md) else: []
  | let md020_issues = if (is_rule_enabled(config, "MD020")): md020(md) else: []
  | let md021_issues = if (is_rule_enabled(config, "MD021")): md021(md) else: []
  | let md022_issues = if (is_rule_enabled(config, "MD022")): md022(md) else: []
  | let md023_issues = if (is_rule_enabled(config, "MD023")): md023(md) else: []
  | let md024_issues = if (is_rule_enabled(config, "MD024")): md024(md, config) else: []
  | let md025_issues = if (is_rule_enabled(config, "MD025")): md025(md, config) else: []
  | let md026_issues = if (is_rule_enabled(config, "MD026")): md026(md, config) else: []
  | let md027_issues = if (is_rule_enabled(config, "MD027")): md027(md) else: []
  | let md028_issues = if (is_rule_enabled(config, "MD028")): md028(md) else: []
  | let md029_issues = if (is_rule_enabled(config, "MD029")): md029(md) else: []
  | let md030_issues = if (is_rule_enabled(config, "MD030")): md030(md) else: []
  | let md031_issues = if (is_rule_enabled(config, "MD031")): md031(md) else: []
  | let md032_issues = if (is_rule_enabled(config, "MD032")): md032(md) else: []
  | let md033_issues = if (is_rule_enabled(config, "MD033")): md033(md, config) else: []
  | let md034_issues = if (is_rule_enabled(config, "MD034")): md034(md) else: []
  | let md035_issues = if (is_rule_enabled(config, "MD035")): md035(md) else: []
  | let md036_issues = if (is_rule_enabled(config, "MD036")): md036(md) else: []
  | let md037_issues = if (is_rule_enabled(config, "MD037")): md037(md) else: []
  | let md038_issues = if (is_rule_enabled(config, "MD038")): md038(md) else: []
  | let md039_issues = if (is_rule_enabled(config, "MD039")): md039(md) else: []
  | let md040_issues = if (is_rule_enabled(config, "MD040")): md040(md, config) else: []
  | let md041_issues = if (is_rule_enabled(config, "MD041")): md041(md) else: []
  | let md046_issues = if (is_rule_enabled(config, "MD046")): md046(md) else: []
  | let md047_issues = if (is_rule_enabled(config, "MD047")): md047(md) else: []
  | let all_issues = flatten([
    md001_issues, md002_issues,
    md003_issues, md004_issues,
    md005_issues, md006_issues,
    md007_issues, md009_issues,
    md010_issues, md011_issues,
    md012_issues, md013_issues,
    md014_issues, md018_issues,
    md019_issues, md020_issues,
    md021_issues, md022_issues,
    md023_issues, md024_issues,
    md025_issues, md026_issues,
    md027_issues, md028_issues,
    md029_issues, md030_issues,
    md031_issues, md032_issues,
    md033_issues, md034_issues,
    md035_issues, md036_issues,
    md037_issues, md038_issues,
    md039_issues, md040_issues,
    md041_issues, md046_issues, md047_issues,
  ])
  | {issues: all_issues, summary: count_by_severity(all_issues)}
end

# Run all lint rules (backward compatibility)
def lint_all(content):
  let config = default_config()
  | lint_all_with_config(content, config)
end

# Generate formatted report
def generate_report(lint_result):
  let issues = lint_result[:issues]
  | let summary = lint_result[:summary]
  | let total = len(issues)
  | if (total == 0):
      s"✅ No issues found! Your Markdown is looking great."
    else:
      do
        let header = s"# Markdown Lint Report
"
        | let errors = summary["errors"]
        | let warnings = summary["warnings"]
        | let info = summary["info"]
        | let summary_text = s"
Found ${total} issues:
" + s"
- ❌ Errors: ${errors}" + s"
- ⚠️  Warnings: ${warnings}" + s"
- ℹ️  Info: ${info}

"
        | let issue_list = s"## Issues

" + join(map(issues, format_issue), "\n") | header + summary_text + issue_list
      end
end
