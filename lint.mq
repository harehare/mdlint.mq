# Markdown Linter - markdownlint Rules Implementation
# This file implements linting rules based on markdownlint
# Reference: https://github.com/markdownlint/markdownlint/blob/main/docs/RULES.m
# MD001: Header levels should only increment by one level at a time
def md001(content):
  let headings = do content | select(.h);
  | let levels = do map(headings, fn(h): attr(h, "level");) | filter(fn(level): level > 0;);
  | let issues = []
  | foreach (i, range(1, len(levels) - 1, 1)):
      let current = levels[i]
      | let previous = levels[i - 1]
      | let diff = current - previous
      | if (diff > 1):
          do
            let heading_node = headings[i]
            | let heading_text = to_text(heading_node)
            | let expected_level = previous + 1
            | let issue = {
              rule: "MD001",
              name: "heading-increment",
              severity: "error",
              message: s"Heading level ${current} skipped (expected level ${expected_level} or lower)",
              heading: heading_text,
              line: i + 1,
              details: {previous_level: previous, current_level: current}
            }
            | issues + issue
          end
        else:
          issues
    end
end

# MD002: First header should be a top level header
def md002(content):
  let headings = do content | select(.h);
  | if (is_empty(headings)): []
    else:
      do
        let first_heading = first(headings)
        | let first_level = attr(first_heading, "level")
        | if (first_level != 1):
            do
              let heading_text = to_text(first_heading)
              | [{
  rule: "MD002",
  name: "first-header-h1",
  severity: "error",
  message: s"First header should be h1 (found h${first_level})",
  heading: heading_text,
  line: 1,
  details: {level: first_level}
}]
            end
          else: []
      end
end


# MD003: Header style consistency
# TODO: Implement header style consistency check
# Requires access to raw markdown text to detect ATX vs Setext styles
def md003(content): []
end

# MD004: Unordered list style
# TODO: Implement unordered list style consistency check
# Requires access to raw markdown text to detect list markers (-, *, +)
def md004(content): []
end

# MD005: List item indentation consistency
# TODO: Implement list item indentation consistency check
# Requires access to raw markdown text
def md005(content): []
end

# MD006: Consider starting bulleted lists at the beginning of the line
# TODO: Implement check for list starting position
# Requires access to raw markdown text
def md006(content): []
end

# MD007: Unordered list indentation
# TODO: Implement unordered list indentation check
# Requires access to raw markdown text to detect indentation levels
def md007(content): []
end

# MD009: Trailing spaces
# TODO: Implement trailing spaces check
# Requires access to raw markdown text to detect line endings
def md009(content): []
end

# MD010: Hard tabs
# TODO: Implement hard tabs check
# Requires access to raw markdown text to detect tab characters
def md010(content): []
end

# MD011: Reversed link syntax
# TODO: Implement check for reversed link syntax
# Requires analysis of text patterns
def md011(content): []
end

# MD012: Multiple consecutive blank lines
# TODO: Implement multiple consecutive blank lines check
# Requires access to raw markdown text
def md012(content): []
end

# MD013: Line length
# TODO: Implement line length check
# Requires access to raw markdown text
def md013(content): []
end

# MD014: Dollar signs used before commands without showing output
# TODO: Implement check for dollar signs in code blocks
# Requires analysis of code block content
def md014(content): []
end

# MD018: No space after hash on atx style header
# TODO: Implement check for space after hash
# Requires access to raw markdown text
def md018(content): []
end

# MD019: Multiple spaces after hash on atx style header
# TODO: Implement check for multiple spaces after hash
# Requires access to raw markdown text
def md019(content): []
end

# MD020: No space inside hashes on closed atx style header
# TODO: Implement check for space inside closing hashes
# Requires access to raw markdown text
def md020(content): []
end

# MD021: Multiple spaces inside hashes on closed atx style header
# TODO: Implement check for multiple spaces inside closing hashes
# Requires access to raw markdown text
def md021(content): []
end

# MD022: Headers should be surrounded by blank lines
def md022(content): []
end

# MD023: Headers must start at the beginning of the line
# TODO: Implement check for header starting position
# Requires access to raw markdown text
def md023(content): []
end

# MD024: Multiple headers with the same content
def md024(content):
  let headings = do content | select(.h);
  | let issues = []
  | let seen = {}
  | foreach (i, range(0, len(headings), 1)):
      let heading = headings[i]
      | let heading_text = to_text(heading)
      | if (contains(seen, heading_text)):
          {
            rule: "MD024",
            name: "no-duplicate-header",
            severity: "warning",
            message: s"Multiple headers with the same content: '${heading_text}'",
            heading: heading_text,
            line: i + 1,
            details: {duplicate_text: heading_text}
          }
        else: do
            let seen = set(seen, heading_text, true)
            | None
          end
    end | compact()
end

# MD025: Multiple top level headers in the same document
def md025(content):
  let headings = do content | select(.h);
  | let h1_headings = filter(headings, fn(h): attr(h, "level") == 1;)
  | if (len(h1_headings) > 1):
      foreach (i, range(1, len(h1_headings), 1)):
        let heading_text = to_text(h1_headings[i]) | {
          rule: "MD025",
          name: "single-h1",
          severity: "error",
          message: s"Multiple top level headers found (h1 should be unique)",
          heading: heading_text,
          line: i + 1,
          details: {}
        }
      end
    else: []
end

# MD026: Trailing punctuation in header
def md026(content):
  let headings = do content | select(.h);
  | let issues = []
  | foreach (i, range(0, len(headings), 1)):
      let heading = headings[i]
      | let heading_text = to_text(heading)
      | let last_char = slice(heading_text, len(heading_text) - 1, len(heading_text))
      | if (last_char == "." || last_char == "," || last_char == ":" || last_char == ";" || last_char == "!" || last_char == "?"):
          do
            let issue = {
              rule: "MD026",
              name: "no-trailing-punctuation",
              severity: "warning",
              message: s"Trailing punctuation in header: '${last_char}'",
              heading: heading_text,
              line: i + 1,
              details: {punctuation: last_char}
            }
            | issues + issue
          end
        else:
          issues
    end
end

# MD027: Multiple spaces after blockquote symbol
# TODO: Implement check for multiple spaces after blockquote
# Requires access to raw markdown text
def md027(content): []
end

# MD028: Blank line inside blockquote
# TODO: Implement check for blank lines in blockquotes
# Requires access to raw markdown text
def md028(content): []
end

# MD029: Ordered list item prefix
# TODO: Implement ordered list prefix consistency check
# Requires access to raw markdown text
def md029(content): []
end

# MD030: Spaces after list markers
# TODO: Implement check for spaces after list markers
# Requires access to raw markdown text
def md030(content): []
end

# MD031: Fenced code blocks should be surrounded by blank lines
# TODO: Implement check for blank lines around code blocks
# Requires access to raw markdown text
def md031(content): []
end

# MD032: Lists should be surrounded by blank lines
# TODO: Implement check for blank lines around lists
# Requires access to raw markdown text
def md032(content): []
end

# MD033: Inline HTML
def md033(content):
  let html_nodes = do content | select(.html);
  | let issues = []
  | foreach (i, range(0, len(html_nodes), 1)):
      let html_node = html_nodes[i]
      | let html_text = to_text(html_node)
      | let issue = {
        rule: "MD033",
        name: "no-inline-html",
        severity: "warning",
        message: s"Inline HTML found: ${html_text}",
        line: i + 1,
        details: {html: html_text}
      }
      | issues + issue
    end
end

# MD034: Bare URL used
# TODO: Implement bare URL detection
# Requires analysis of link nodes
def md034(content): []
end

# MD035: Horizontal rule style
# TODO: Implement horizontal rule style consistency check
# Requires access to raw markdown text
def md035(content): []
end

# MD036: Emphasis used instead of a header
# TODO: Implement check for emphasis misused as header
# Requires semantic analysis
def md036(content): []
end

# MD037: Spaces inside emphasis markers
# TODO: Implement check for spaces inside emphasis
# Requires access to raw markdown text
def md037(content): []
end

# MD038: Spaces inside code span elements
# TODO: Implement check for spaces inside code spans
# Requires access to raw markdown text
def md038(content): []
end

# MD039: Spaces inside link text
# TODO: Implement check for spaces inside link text
# Requires access to raw markdown text
def md039(content): []
end

# MD040: Fenced code blocks should have a language specified
def md040(content):
  let code_blocks = do content | select(.code_block);
  | let issues = []
  | foreach (i, range(0, len(code_blocks), 1)):
      let code_block = code_blocks[i]
      | let language = attr(code_block, "lang")
      | if (is_empty(language)):
          do
            let issue = {
              rule: "MD040",
              name: "fenced-code-language",
              severity: "warning",
              message: "Fenced code block should have a language specified",
              line: i + 1,
              details: {}
            }
            | issues + issue
          end
        else:
          issues
    end
end

# MD041: First line in file should be a top level header
def md041(content): []
end

# MD046: Code block style
# TODO: Implement code block style consistency check
# Requires access to raw markdown text
def md046(content): []
end

# MD047: File should end with a single newline character
# TODO: Implement check for file ending
# Requires access to raw markdown text
def md047(content): []
end

# Format a single issue for display
def format_issue(issue):
  let rule = get(issue, "rule")
  | let name = get(issue, "name")
  | let line = try: issue["line"] catch: "?"
  | let severity = issue["severity"]
  | let message = issue["message"]
  | let severity_icon = match (severity):
      | "error": "❌"
      | "warning": "⚠️"
      | "info": "ℹ️"
      | _: "•"
    end
  | s"${line}:1 ${severity_icon} ${rule} (${name}) - ${message}"
end

# Count issues by severity
def count_by_severity(issues):
  let errors = do filter(issues, fn(i): eq(get(i, "severity"), "error");) | len();
  | let warnings = do filter(issues, fn(i): eq(get(i, "severity"), "warning");) | len();
  | let info = do filter(issues, fn(i): eq(get(i, "severity"), "info");) | len();
  | {
  "errors": errors,
  "warnings": warnings,
  "info": info,
  "total": len(issues)
}
end

# Run all lint rules
def lint_all(content):
  let md001_issues = md001(content)
  | let md002_issues = md002(content)
  | let md003_issues = md003(content)
  | let md004_issues = md004(content)
  | let md005_issues = md005(content)
  | let md006_issues = md006(content)
  | let md007_issues = md007(content)
  | let md009_issues = md009(content)
  | let md010_issues = md010(content)
  | let md011_issues = md011(content)
  | let md012_issues = md012(content)
  | let md013_issues = md013(content)
  | let md014_issues = md014(content)
  | let md018_issues = md018(content)
  | let md019_issues = md019(content)
  | let md020_issues = md020(content)
  | let md021_issues = md021(content)
  | let md022_issues = md022(content)
  | let md023_issues = md023(content)
  | let md024_issues = md024(content)
  | let md025_issues = md025(content)
  | let md026_issues = md026(content)
  | let md027_issues = md027(content)
  | let md028_issues = md028(content)
  | let md029_issues = md029(content)
  | let md030_issues = md030(content)
  | let md031_issues = md031(content)
  | let md032_issues = md032(content)
  | let md033_issues = md033(content)
  | let md034_issues = md034(content)
  | let md035_issues = md035(content)
  | let md036_issues = md036(content)
  | let md037_issues = md037(content)
  | let md038_issues = md038(content)
  | let md039_issues = md039(content)
  | let md040_issues = md040(content)
  | let md041_issues = md041(content)
  | let md046_issues = md046(content)
  | let md047_issues = md047(content)
  | let all_issues = flatten([
    md001_issues, md002_issues, md003_issues, md004_issues,
    md005_issues, md006_issues, md007_issues, md009_issues,
    md010_issues, md011_issues, md012_issues, md013_issues,
    md014_issues, md018_issues, md019_issues, md020_issues,
    md021_issues, md022_issues, md023_issues, md024_issues,
    md025_issues, md026_issues, md027_issues, md028_issues,
    md029_issues, md030_issues, md031_issues, md032_issues,
    md033_issues, md034_issues, md035_issues, md036_issues,
    md037_issues, md038_issues, md039_issues, md040_issues,
    md041_issues, md046_issues, md047_issues
  ])
  | {issues: all_issues, summary: count_by_severity(all_issues)}
end

# Generate formatted report
def generate_report(lint_result):
  let issues = lint_result[:issues]
  | let summary = lint_result[:summary]
  | let total = len(issues)
  | if (total == 0):
      s"✅ No issues found! Your Markdown is looking great."
    else:
      do
        let header = s"# Markdown Lint Report
"
        | let errors = summary["errors"]
        | let warnings = summary["warnings"]
        | let info = summary["info"]
        | let summary_text = s"
Found ${total} issues:
" + s"
- ❌ Errors: ${errors}" + s"
- ⚠️  Warnings: ${warnings}" + s"
- ℹ️  Info: ${info}

"
        | let issue_list = s"## Issues

" + join(map(issues, format_issue), "\n") | header + summary_text + issue_list
      end
end
